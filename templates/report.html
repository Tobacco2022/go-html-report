<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="99999999">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Report - {{ .Title }}</title>
    <style type="text/css">
        {{style.css}}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Test Report</h1>
            <p class="subtitle">{{ .Title }}</p>
        </header>

        <div class="summary">
            <div class="stat-card success">
                <div class="stat-number" id="passCount">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card failed">
                <div class="stat-number" id="failCount">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card skipped">
                <div class="stat-number" id="skipCount">0</div>
                <div class="stat-label">Skipped</div>
            </div>
            <div class="stat-card total">
                <div class="stat-number" id="totalCount">0</div>
                <div class="stat-label">Total</div>
            </div>
        </div>

        <div class="filter-buttons">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="failed">Failed</button>
        </div>

        {{range .Report.Suites }}
        <div class="test-suite">
            <h2 class="suite-name">{{ .Name }}</h2>
            {{ range .TestCases }}
            <div class="test-item outcome-{{ .Outcome | lower }}" data-outcome="{{ .Outcome | lower }}">
                <div class="test-header">
                    <div class="test-info">
                        <span class="test-status status-{{ .Outcome | lower }}">{{ .Outcome }}</span>
                        <span class="test-name">{{ .Name }}</span>
                        <span class="test-duration">{{ .Time }}s</span>
                    </div>
                    {{if or .Failure .SkipMessage }}
                    <button class="toggle-detail">▼</button>
                    {{end}}
                </div>
                {{if .Failure }}
                <pre class="test-output">{{ .Failure.Contents }}</pre>
                {{end}}
                {{if .SkipMessage }}
                <pre class="test-output">{{ .SkipMessage.Message }}</pre>
                {{end}}
            </div>
            {{end}}
        </div>
        {{ end }}
    </div>


    <script>
        // 树形结构处理函数
        function toTree(tcs) {
            var tcArr = tcs.map(function(e) {
                var parts = e.split("/");
                var parentKey = "";
                if (parts.length > 1) {
                    parts.pop();
                    parentKey = parts.join("/");
                }
                return {
                    "children": [],
                    "parentKey": parentKey,
                    "key": e
                };
            });

            var tcMap = {};
            tcArr.forEach(function(e) {
                tcMap[e.key] = e;
            });

            var tcArrNew = [];
            tcArr.forEach(item => {
                const parent = tcMap[item.parentKey];
                if (parent) {
                    parent.children.push(item);
                } else {
                    tcArrNew.push(item);
                }
            });

            return tcArrNew;
        }

        function extractTree(arrs, children) {
            let attrList = [];
            if (!Array.isArray(arrs) || !arrs.length) return [];
            if (typeof children !== 'string') return [];
            
            attrList = Object.keys(arrs[0]);
            attrList.splice(attrList.indexOf(children), 1);
            let list = [];
            
            const getObj = (arr) => {
                arr.forEach(function(row) {
                    let obj = {};
                    attrList.forEach(item => {
                        obj[item] = row[item];
                    });
                    list.push(obj);
                    if (row[children]) {
                        getObj(row[children]);
                    }
                });
                return list;
            };
            return getObj(arrs);
        }

        // 统计数据
        document.addEventListener('DOMContentLoaded', function() {
            const items = document.querySelectorAll('.test-item');
            let total = items.length;
            let passed = document.querySelectorAll('.outcome-success').length;
            let failed = document.querySelectorAll('.outcome-failed').length;
            let skipped = document.querySelectorAll('.outcome-skipped').length;

            document.getElementById('totalCount').textContent = total;
            document.getElementById('passCount').textContent = passed;
            document.getElementById('failCount').textContent = failed;
            document.getElementById('skipCount').textContent = skipped;

            // 树形排序和层级缩进
            var tcs = [];
            items.forEach(function(item) {
                var testName = item.querySelector('.test-name').textContent;
                tcs.push(testName);
            });

            var tctree = toTree(tcs);
            var newArr = extractTree(tctree, "children");
            var Imap = {};
            newArr.forEach(function(e, i) {
                Imap[e.key] = i;
            });

            // 按树形顺序重排测试项
            document.querySelectorAll('.test-suite').forEach(function(suite) {
                var container = suite;
                var arr = Array.from(suite.querySelectorAll('.test-item'));
                
                arr.forEach(function(item) {
                    var tcname = item.querySelector('.test-name').textContent;
                    item.setAttribute('data-id', Imap[tcname]);
                    item.setAttribute('data-testname', tcname);
                });
                
                arr.sort(function(a, b) {
                    return a.getAttribute('data-id') - b.getAttribute('data-id');
                });
                
                arr.forEach(function(item) {
                    container.appendChild(item);
                });
            });

            // 设置层级缩进
            items.forEach(function(item) {
                var tc = item.querySelector('.test-name').textContent;
                var level = (tc.split("/").length - 1);
                var ml = level * 2; // 2em per level
                item.style.marginLeft = ml + "em";
                item.setAttribute('data-level', level);
            });

            // 点击父测试折叠/展开子测试
            items.forEach(function(item) {
                var header = item.querySelector('.test-header');
                header.style.cursor = 'pointer';
                header.setAttribute('data-collapsed', '0');
                
                header.addEventListener('click', function(e) {
                    // 如果点击的是 toggle-detail 按钮，不触发折叠逻辑
                    if (e.target.classList.contains('toggle-detail')) {
                        return;
                    }
                    
                    var tcname = item.getAttribute('data-testname');
                    var isCollapsed = this.getAttribute('data-collapsed');
                    var showFilter = item.closest('.test-suite').getAttribute('data-show-filter');
                    var currentLevel = parseInt(item.getAttribute('data-level'));
                    
                    if (isCollapsed === '1') {
                        // 展开子测试
                        if (currentLevel === 0 && showFilter) {
                            // level=0 (Suite) 且有筛选：只展开符合条件的 level=1 及其所有子测试
                            var allItems = document.querySelectorAll('.test-item');
                            allItems.forEach(function(testItem) {
                                var tc = testItem.getAttribute('data-testname');
                                var testLevel = parseInt(testItem.getAttribute('data-level'));
                                
                                // 检查是否是直接子测试（level=1）
                                if (tc && tc.startsWith(tcname + "/")) {
                                    var parts = tc.split("/");
                                    var isDirectChild = parts.length === tcname.split("/").length + 1;
                                    
                                    if (isDirectChild) {
                                        // 直接子测试：检查状态是否匹配
                                        if (testItem.dataset.outcome === showFilter) {
                                            testItem.style.display = 'block';
                                            // 展开该子测试的所有子测试
                                            var grandChildren = getChildTests(tc, allItems);
                                            grandChildren.forEach(function(gc) {
                                                gc.style.display = 'block';
                                            });
                                        }
                                    }
                                }
                            });
                        } else {
                            // level>=1 或无筛选：展开所有子测试
                            var allItems = document.querySelectorAll('.test-item');
                            allItems.forEach(function(testItem) {
                                var tc = testItem.getAttribute('data-testname');
                                if (tc && tc.startsWith(tcname + "/")) {
                                    testItem.style.display = 'block';
                                }
                            });
                        }
                        this.setAttribute('data-collapsed', '0');
                    } else {
                        // 折叠子测试
                        document.querySelectorAll('.test-item').forEach(function(testItem) {
                            var tc = testItem.getAttribute('data-testname');
                            if (tc && tc.startsWith(tcname + "/")) {
                                testItem.style.display = 'none';
                                testItem.querySelector('.test-header').setAttribute('data-collapsed', '1');
                            }
                        });
                        this.setAttribute('data-collapsed', '1');
                    }
                });
            });

            // 辅助函数：获取所有子测试
            function getChildTests(testName, allItems) {
                const children = [];
                allItems.forEach(item => {
                    const tc = item.getAttribute('data-testname');
                    if (tc && tc.startsWith(testName + "/")) {
                        children.push(item);
                    }
                });
                return children;
            }

            // 辅助函数：获取直接父测试
            function getParentTest(testName, allItems) {
                const parts = testName.split("/");
                if (parts.length <= 1) return null;
                
                const parentName = parts.slice(0, -1).join("/");
                return Array.from(allItems).find(item => 
                    item.getAttribute('data-testname') === parentName
                );
            }

            // 筛选功能 - 根据第二层测试状态筛选
            const filterBtns = document.querySelectorAll('.filter-btn[data-filter]');
            filterBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    filterBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    const filter = this.dataset.filter;
                    
                    // 重置折叠状态
                    items.forEach(item => {
                        item.querySelector('.test-header').setAttribute('data-collapsed', '0');
                    });
                    
                    document.querySelectorAll('.test-suite').forEach(suite => {
                        if (filter === 'all') {
                            suite.removeAttribute('data-show-filter');
                        } else {
                            suite.setAttribute('data-show-filter', filter);
                        }
                    });
                    
                    if (filter === 'all') {
                        // 显示所有测试
                        items.forEach(item => {
                            item.style.display = 'block';
                        });
                    } else {
                        // 先隐藏所有测试
                        items.forEach(item => {
                            item.style.display = 'none';
                        });
                        
                        const itemsToShow = new Set();
                        
                        // 只遍历第二层测试（level === 1）
                        items.forEach(item => {
                            const level = parseInt(item.getAttribute('data-level'));
                            
                            if (level === 1 && item.dataset.outcome === filter) {
                                // 第二层测试状态匹配
                                const testName = item.getAttribute('data-testname');
                                
                                // 添加该测试本身
                                itemsToShow.add(item);
                                
                                // 添加第一层父测试（Suite）
                                const parentTest = getParentTest(testName, items);
                                if (parentTest) {
                                    itemsToShow.add(parentTest);
                                }
                                
                                // 添加该测试的所有子测试（无论子测试是什么状态）
                                const children = getChildTests(testName, items);
                                children.forEach(child => {
                                    itemsToShow.add(child);
                                });
                            }
                        });
                        
                        // 显示收集到的测试项
                        itemsToShow.forEach(item => {
                            item.style.display = 'block';
                        });
                    }
                });
            });

            // 展开/收起详情（错误输出）
            document.querySelectorAll('.toggle-detail').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const output = this.closest('.test-item').querySelector('.test-output');
                    if (output) {
                        const isVisible = output.style.display === 'block';
                        output.style.display = isVisible ? 'none' : 'block';
                        this.textContent = isVisible ? '▼' : '▲';
                    }
                });
            });

            // 默认隐藏所有输出
            document.querySelectorAll('.test-output').forEach(output => {
                output.style.display = 'none';
            });
        });
    </script>
</body>
</html>